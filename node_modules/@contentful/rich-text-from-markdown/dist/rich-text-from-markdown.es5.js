'use strict';

var richTextTypes = require('@contentful/rich-text-types');
var _ = require('lodash');
var gfm = require('remark-gfm');
var markdown = require('remark-parse');
var unified = require('unified');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var markdownNodeTypes = new Map([
    ['paragraph', richTextTypes.BLOCKS.PARAGRAPH],
    ['heading', 'heading'],
    ['text', 'text'],
    ['emphasis', 'text'],
    ['strong', 'text'],
    ['delete', 'text'],
    ['inlineCode', 'text'],
    ['link', richTextTypes.INLINES.HYPERLINK],
    ['thematicBreak', richTextTypes.BLOCKS.HR],
    ['blockquote', richTextTypes.BLOCKS.QUOTE],
    ['list', 'list'],
    ['listItem', richTextTypes.BLOCKS.LIST_ITEM],
    ['table', richTextTypes.BLOCKS.TABLE],
    ['tableRow', richTextTypes.BLOCKS.TABLE_ROW],
    ['tableCell', richTextTypes.BLOCKS.TABLE_CELL],
]);
var nodeTypeFor = function (node) {
    var nodeType = markdownNodeTypes.get(node.type);
    switch (nodeType) {
        case 'heading':
            return "".concat(nodeType, "-").concat(node.depth);
        case 'list':
            return "".concat(node.ordered ? 'ordered' : 'unordered', "-list");
        default:
            return nodeType;
    }
};
var markTypes = new Map([
    ['emphasis', 'italic'],
    ['strong', 'bold'],
    ['inlineCode', 'code'],
]);
var markTypeFor = function (node) {
    return markTypes.get(node.type);
};
var isLink = function (node) {
    return node.type === 'link';
};
var nodeContainerTypes = new Map([
    ['delete', 'block'],
    [richTextTypes.BLOCKS.HEADING_1, 'block'],
    [richTextTypes.BLOCKS.HEADING_2, 'block'],
    [richTextTypes.BLOCKS.HEADING_3, 'block'],
    [richTextTypes.BLOCKS.HEADING_4, 'block'],
    [richTextTypes.BLOCKS.HEADING_5, 'block'],
    [richTextTypes.BLOCKS.HEADING_6, 'block'],
    [richTextTypes.BLOCKS.LIST_ITEM, 'block'],
    [richTextTypes.BLOCKS.UL_LIST, 'block'],
    [richTextTypes.BLOCKS.OL_LIST, 'block'],
    [richTextTypes.BLOCKS.QUOTE, 'block'],
    [richTextTypes.BLOCKS.HR, 'block'],
    [richTextTypes.BLOCKS.PARAGRAPH, 'block'],
    [richTextTypes.BLOCKS.TABLE, 'block'],
    [richTextTypes.BLOCKS.TABLE_CELL, 'block'],
    [richTextTypes.BLOCKS.TABLE_HEADER_CELL, 'block'],
    [richTextTypes.BLOCKS.TABLE_ROW, 'block'],
    [richTextTypes.INLINES.HYPERLINK, 'inline'],
    ['text', 'text'],
    ['emphasis', 'text'],
    ['strong', 'text'],
    ['inlineCode', 'text'],
]);
var isBlock = function (nodeType) {
    return nodeContainerTypes.get(nodeType) === 'block';
};
var isText = function (nodeType) {
    return nodeContainerTypes.get(nodeType) === 'text';
};
var isInline = function (nodeType) {
    return nodeContainerTypes.get(nodeType) === 'inline';
};
var isTableCell = function (nodeType) {
    return nodeType === richTextTypes.BLOCKS.TABLE_CELL;
};
var buildHyperlink = function (node, fallback, appliedMarksTypes) { return __awaiter(void 0, void 0, void 0, function () {
    var content, hyperlink;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, mdToRichTextNodes(node.children, fallback, appliedMarksTypes)];
            case 1:
                content = (_a.sent());
                hyperlink = {
                    nodeType: richTextTypes.INLINES.HYPERLINK,
                    data: { uri: node.url },
                    content: content,
                };
                return [2 /*return*/, [hyperlink]];
        }
    });
}); };
var buildGenericBlockOrInline = function (node, fallback, appliedMarksTypes) { return __awaiter(void 0, void 0, void 0, function () {
    var nodeType, content;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                nodeType = nodeTypeFor(node);
                return [4 /*yield*/, mdToRichTextNodes(node.children, fallback, appliedMarksTypes)];
            case 1:
                content = _a.sent();
                return [2 /*return*/, [
                        {
                            nodeType: nodeType,
                            content: content,
                            data: {},
                        },
                    ]];
        }
    });
}); };
var buildTableCell = function (node, fallback, appliedMarksTypes) { return __awaiter(void 0, void 0, void 0, function () {
    var nodeChildren, content;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, mdToRichTextNodes(node.children, fallback, appliedMarksTypes)];
            case 1:
                nodeChildren = _a.sent();
                content = nodeChildren.reduce(function (result, contentNode) {
                    if (isText(contentNode.nodeType) || isInline(contentNode.nodeType)) {
                        var lastNode = result[result.length - 1];
                        if (lastNode && lastNode.nodeType === richTextTypes.BLOCKS.PARAGRAPH) {
                            lastNode.content.push(contentNode);
                        }
                        else {
                            result.push({ nodeType: richTextTypes.BLOCKS.PARAGRAPH, data: {}, content: [contentNode] });
                        }
                    }
                    else {
                        result.push(contentNode);
                    }
                    return result;
                }, []);
                // A table cell can't be empty
                if (content.length === 0) {
                    content.push({
                        nodeType: richTextTypes.BLOCKS.PARAGRAPH,
                        data: {},
                        content: [
                            {
                                nodeType: 'text',
                                data: {},
                                marks: [],
                                value: '',
                            },
                        ],
                    });
                }
                /**
                 * We should only support texts inside table cells.
                 * Some markdowns might contain html inside tables such as <ul>, <blockquote>, etc
                 * but they are pretty much filtered out by markdownNodeTypes and nodeContainerTypes variables.
                 * so we ended up receiving only `text` nodes.
                 * We can't have table cells with text nodes directly, we must wrap text nodes inside paragraphs.
                 */
                return [2 /*return*/, [
                        {
                            nodeType: richTextTypes.BLOCKS.TABLE_CELL,
                            content: content,
                            data: {},
                        },
                    ]];
        }
    });
}); };
var buildText = function (node, fallback, appliedMarksTypes) { return __awaiter(void 0, void 0, void 0, function () {
    var nodeType, markType, marks;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                nodeType = nodeTypeFor(node);
                markType = markTypeFor(node);
                marks = Array.from(appliedMarksTypes);
                if (markType) {
                    marks.push(markType);
                }
                if (!(node.type !== 'text' && node.children)) return [3 /*break*/, 2];
                return [4 /*yield*/, mdToRichTextNodes(node.children, fallback, marks)];
            case 1: return [2 /*return*/, (_a.sent())];
            case 2:
                if (node.value) {
                    return [2 /*return*/, [
                            {
                                nodeType: nodeType,
                                value: node.value,
                                marks: marks.map(function (type) { return ({ type: type }); }),
                                data: {},
                            },
                        ]];
                }
                return [2 /*return*/];
        }
    });
}); };
var buildFallbackNode = function (node, fallback) { return __awaiter(void 0, void 0, void 0, function () {
    var fallbackResult;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fallback(node)];
            case 1:
                fallbackResult = _a.sent();
                if (_.isArray(fallbackResult)) {
                    return [2 /*return*/, fallbackResult];
                }
                return [2 /*return*/, [fallbackResult]];
        }
    });
}); };
function mdToRichTextNode(node_1, fallback_1) {
    return __awaiter(this, arguments, void 0, function (node, fallback, appliedMarksTypes) {
        var nodeType;
        if (appliedMarksTypes === void 0) { appliedMarksTypes = []; }
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // By default <br/> is parsed as html node, causing it to be stripped out.
                    // We need to convert it manually in order to support it
                    if (node.type === 'html' && /<br\s?\/?>/gi.test(node.value)) {
                        node.value = '\n';
                        node.type = 'text';
                    }
                    nodeType = nodeTypeFor(node);
                    if (!isLink(node)) return [3 /*break*/, 2];
                    return [4 /*yield*/, buildHyperlink(node, fallback, appliedMarksTypes)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    if (!isTableCell(nodeType)) return [3 /*break*/, 4];
                    return [4 /*yield*/, buildTableCell(node, fallback, appliedMarksTypes)];
                case 3: return [2 /*return*/, _a.sent()];
                case 4:
                    if (!(isBlock(nodeType) || isInline(nodeType))) return [3 /*break*/, 6];
                    return [4 /*yield*/, buildGenericBlockOrInline(node, fallback, appliedMarksTypes)];
                case 5: return [2 /*return*/, _a.sent()];
                case 6:
                    if (!isText(nodeType)) return [3 /*break*/, 8];
                    return [4 /*yield*/, buildText(node, fallback, appliedMarksTypes)];
                case 7: return [2 /*return*/, _a.sent()];
                case 8: return [4 /*yield*/, buildFallbackNode(node, fallback)];
                case 9: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function mdToRichTextNodes(nodes_1, fallback_1) {
    return __awaiter(this, arguments, void 0, function (nodes, fallback, appliedMarksTypes) {
        var rtNodes;
        if (appliedMarksTypes === void 0) { appliedMarksTypes = []; }
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!nodes) {
                        return [2 /*return*/, Promise.resolve([])];
                    }
                    return [4 /*yield*/, Promise.all(nodes.map(function (node) { return mdToRichTextNode(node, fallback, appliedMarksTypes); }))];
                case 1:
                    rtNodes = _a.sent();
                    return [2 /*return*/, _.flatten(rtNodes).filter(Boolean)];
            }
        });
    });
}
var astToRichTextDocument = function (tree, fallback) { return __awaiter(void 0, void 0, void 0, function () {
    var content;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, mdToRichTextNodes(tree.children, fallback)];
            case 1:
                content = _a.sent();
                return [2 /*return*/, {
                        nodeType: richTextTypes.BLOCKS.DOCUMENT,
                        data: {},
                        content: content,
                    }];
        }
    });
}); };
function expandParagraphWithInlineImages(node) {
    if (node.type !== 'paragraph') {
        return [node];
    }
    var imageNodeIndices = [];
    for (var i = 0; i < node.children.length; i++) {
        if (node.children[i].type === 'image') {
            imageNodeIndices.push(i);
        }
    }
    if (imageNodeIndices.length === 0) {
        // If no images in children, return.
        return [node];
    }
    var allNodes = [];
    var lastIndex = -1;
    for (var j = 0; j < imageNodeIndices.length; j++) {
        var index = imageNodeIndices[j];
        // before
        if (index !== 0) {
            var nodesBefore = node.children.slice(lastIndex + 1, index);
            if (nodesBefore.length > 0) {
                allNodes.push(__assign(__assign({}, node), { children: nodesBefore }));
            }
        }
        // image
        var imageNode = node.children[index];
        allNodes.push(imageNode);
        // till end
        var nodesAfter = [];
        var rangeEnd = j + 1 < imageNodeIndices.length ? imageNodeIndices[j + 1] : node.children.length;
        if (index + 1 < rangeEnd && index === imageNodeIndices.slice(-1)[0]) {
            nodesAfter = node.children.slice(index + 1, rangeEnd);
            if (nodesAfter.length > 0) {
                allNodes.push(__assign(__assign({}, node), { children: nodesAfter }));
            }
        }
        lastIndex = index;
    }
    return allNodes;
}
// Inline markdown images come in as nested within a MarkdownNode paragraph
// so we must hoist them out before transforming to rich text.
function prepareMdAST(ast) {
    function prepareASTNodeChildren(node) {
        if (!node.children) {
            return node;
        }
        var children = _.flatMap(node.children, function (n) { return expandParagraphWithInlineImages(n); }).map(function (n) {
            return prepareASTNodeChildren(n);
        });
        return __assign(__assign({}, node), { children: children });
    }
    return prepareASTNodeChildren({
        depth: '0',
        type: 'root',
        value: '',
        ordered: true,
        children: ast.children,
    });
}
function richTextFromMarkdown(md_1) {
    return __awaiter(this, arguments, void 0, function (md, fallback) {
        var processor, tree, ast;
        if (fallback === void 0) { fallback = function () { return Promise.resolve(null); }; }
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    processor = unified().use(markdown).use(gfm);
                    tree = processor.parse(md);
                    ast = prepareMdAST(tree);
                    return [4 /*yield*/, astToRichTextDocument(ast, fallback)];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}

exports.richTextFromMarkdown = richTextFromMarkdown;
//# sourceMappingURL=rich-text-from-markdown.es5.js.map
