'use strict';

var isPlainObject = require('is-plain-obj');

/**
 * Map of all Contentful block types. Blocks contain inline or block nodes.
 */
exports.BLOCKS = void 0;
(function (BLOCKS) {
    BLOCKS["DOCUMENT"] = "document";
    BLOCKS["PARAGRAPH"] = "paragraph";
    BLOCKS["HEADING_1"] = "heading-1";
    BLOCKS["HEADING_2"] = "heading-2";
    BLOCKS["HEADING_3"] = "heading-3";
    BLOCKS["HEADING_4"] = "heading-4";
    BLOCKS["HEADING_5"] = "heading-5";
    BLOCKS["HEADING_6"] = "heading-6";
    BLOCKS["OL_LIST"] = "ordered-list";
    BLOCKS["UL_LIST"] = "unordered-list";
    BLOCKS["LIST_ITEM"] = "list-item";
    BLOCKS["HR"] = "hr";
    BLOCKS["QUOTE"] = "blockquote";
    BLOCKS["EMBEDDED_ENTRY"] = "embedded-entry-block";
    BLOCKS["EMBEDDED_ASSET"] = "embedded-asset-block";
    BLOCKS["EMBEDDED_RESOURCE"] = "embedded-resource-block";
    BLOCKS["TABLE"] = "table";
    BLOCKS["TABLE_ROW"] = "table-row";
    BLOCKS["TABLE_CELL"] = "table-cell";
    BLOCKS["TABLE_HEADER_CELL"] = "table-header-cell";
})(exports.BLOCKS || (exports.BLOCKS = {}));

/**
 * Map of all Contentful inline types. Inline contain inline or text nodes.
 *
 * @note This should be kept in alphabetical order since the
 * [validation package](https://github.com/contentful/content-stack/tree/master/packages/validation)
 *  relies on the values being in a predictable order.
 */
exports.INLINES = void 0;
(function (INLINES) {
    INLINES["ASSET_HYPERLINK"] = "asset-hyperlink";
    INLINES["EMBEDDED_ENTRY"] = "embedded-entry-inline";
    INLINES["EMBEDDED_RESOURCE"] = "embedded-resource-inline";
    INLINES["ENTRY_HYPERLINK"] = "entry-hyperlink";
    INLINES["HYPERLINK"] = "hyperlink";
    INLINES["RESOURCE_HYPERLINK"] = "resource-hyperlink";
})(exports.INLINES || (exports.INLINES = {}));

/**
 * Map of all Contentful marks.
 */
exports.MARKS = void 0;
(function (MARKS) {
    MARKS["BOLD"] = "bold";
    MARKS["ITALIC"] = "italic";
    MARKS["UNDERLINE"] = "underline";
    MARKS["CODE"] = "code";
    MARKS["SUPERSCRIPT"] = "superscript";
    MARKS["SUBSCRIPT"] = "subscript";
    MARKS["STRIKETHROUGH"] = "strikethrough";
})(exports.MARKS || (exports.MARKS = {}));

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var _a$1;
/**
 * Array of all top level block types.
 * Only these block types can be the direct children of the document.
 */
var TOP_LEVEL_BLOCKS = [
    exports.BLOCKS.PARAGRAPH,
    exports.BLOCKS.HEADING_1,
    exports.BLOCKS.HEADING_2,
    exports.BLOCKS.HEADING_3,
    exports.BLOCKS.HEADING_4,
    exports.BLOCKS.HEADING_5,
    exports.BLOCKS.HEADING_6,
    exports.BLOCKS.OL_LIST,
    exports.BLOCKS.UL_LIST,
    exports.BLOCKS.HR,
    exports.BLOCKS.QUOTE,
    exports.BLOCKS.EMBEDDED_ENTRY,
    exports.BLOCKS.EMBEDDED_ASSET,
    exports.BLOCKS.EMBEDDED_RESOURCE,
    exports.BLOCKS.TABLE,
];
/**
 * Array of all allowed block types inside list items
 */
var LIST_ITEM_BLOCKS = [
    exports.BLOCKS.PARAGRAPH,
    exports.BLOCKS.HEADING_1,
    exports.BLOCKS.HEADING_2,
    exports.BLOCKS.HEADING_3,
    exports.BLOCKS.HEADING_4,
    exports.BLOCKS.HEADING_5,
    exports.BLOCKS.HEADING_6,
    exports.BLOCKS.OL_LIST,
    exports.BLOCKS.UL_LIST,
    exports.BLOCKS.HR,
    exports.BLOCKS.QUOTE,
    exports.BLOCKS.EMBEDDED_ENTRY,
    exports.BLOCKS.EMBEDDED_ASSET,
    exports.BLOCKS.EMBEDDED_RESOURCE,
];
var TABLE_BLOCKS = [
    exports.BLOCKS.TABLE,
    exports.BLOCKS.TABLE_ROW,
    exports.BLOCKS.TABLE_CELL,
    exports.BLOCKS.TABLE_HEADER_CELL,
];
/**
 * Array of all void block types
 */
var VOID_BLOCKS = [
    exports.BLOCKS.HR,
    exports.BLOCKS.EMBEDDED_ENTRY,
    exports.BLOCKS.EMBEDDED_ASSET,
    exports.BLOCKS.EMBEDDED_RESOURCE,
];
/**
 * Dictionary of all container block types, and the set block types they accept as children.
 *
 * Note: This does not include `[BLOCKS.DOCUMENT]: TOP_LEVEL_BLOCKS`
 */
var CONTAINERS = (_a$1 = {},
    _a$1[exports.BLOCKS.OL_LIST] = [exports.BLOCKS.LIST_ITEM],
    _a$1[exports.BLOCKS.UL_LIST] = [exports.BLOCKS.LIST_ITEM],
    _a$1[exports.BLOCKS.LIST_ITEM] = LIST_ITEM_BLOCKS,
    _a$1[exports.BLOCKS.QUOTE] = [exports.BLOCKS.PARAGRAPH],
    _a$1[exports.BLOCKS.TABLE] = [exports.BLOCKS.TABLE_ROW],
    _a$1[exports.BLOCKS.TABLE_ROW] = [exports.BLOCKS.TABLE_CELL, exports.BLOCKS.TABLE_HEADER_CELL],
    _a$1[exports.BLOCKS.TABLE_CELL] = [exports.BLOCKS.PARAGRAPH, exports.BLOCKS.UL_LIST, exports.BLOCKS.OL_LIST],
    _a$1[exports.BLOCKS.TABLE_HEADER_CELL] = [exports.BLOCKS.PARAGRAPH],
    _a$1);
/**
 * Array of all heading levels
 */
var HEADINGS = [
    exports.BLOCKS.HEADING_1,
    exports.BLOCKS.HEADING_2,
    exports.BLOCKS.HEADING_3,
    exports.BLOCKS.HEADING_4,
    exports.BLOCKS.HEADING_5,
    exports.BLOCKS.HEADING_6,
];
/**
 * Array of all block types that may contain text and inline nodes.
 */
var TEXT_CONTAINERS = __spreadArray([exports.BLOCKS.PARAGRAPH], HEADINGS, true);
/**
 * Node types before `tables` release.
 */
var V1_NODE_TYPES = [
    exports.BLOCKS.DOCUMENT,
    exports.BLOCKS.PARAGRAPH,
    exports.BLOCKS.HEADING_1,
    exports.BLOCKS.HEADING_2,
    exports.BLOCKS.HEADING_3,
    exports.BLOCKS.HEADING_4,
    exports.BLOCKS.HEADING_5,
    exports.BLOCKS.HEADING_6,
    exports.BLOCKS.OL_LIST,
    exports.BLOCKS.UL_LIST,
    exports.BLOCKS.LIST_ITEM,
    exports.BLOCKS.HR,
    exports.BLOCKS.QUOTE,
    exports.BLOCKS.EMBEDDED_ENTRY,
    exports.BLOCKS.EMBEDDED_ASSET,
    exports.INLINES.HYPERLINK,
    exports.INLINES.ENTRY_HYPERLINK,
    exports.INLINES.ASSET_HYPERLINK,
    exports.INLINES.EMBEDDED_ENTRY,
    'text',
];
/**
 * Marks before `superscript` & `subscript` release.
 */
var V1_MARKS = [exports.MARKS.BOLD, exports.MARKS.CODE, exports.MARKS.ITALIC, exports.MARKS.UNDERLINE];

/**
 * A rich text document considered to be empty.
 * Any other document structure than this is not considered empty.
 */
var EMPTY_DOCUMENT = {
    nodeType: exports.BLOCKS.DOCUMENT,
    data: {},
    content: [
        {
            nodeType: exports.BLOCKS.PARAGRAPH,
            data: {},
            content: [
                {
                    nodeType: 'text',
                    value: '',
                    marks: [],
                    data: {},
                },
            ],
        },
    ],
};

/**
 * Tiny replacement for Object.values(object).includes(key) to
 * avoid including CoreJS polyfills
 */
function hasValue(obj, value) {
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var key = _a[_i];
        if (value === obj[key]) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if the node is an instance of Inline.
 */
function isInline(node) {
    return hasValue(exports.INLINES, node.nodeType);
}
/**
 * Checks if the node is an instance of Block.
 */
function isBlock(node) {
    return hasValue(exports.BLOCKS, node.nodeType);
}
/**
 * Checks if the node is an instance of Text.
 */
function isText(node) {
    return node.nodeType === 'text';
}

var helpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isBlock: isBlock,
  isInline: isInline,
  isText: isText
});

var typeMismatchError = function (_a) {
    var path = _a.path, property = _a.property, typeName = _a.typeName, value = _a.value;
    return {
        details: "The type of \"".concat(property, "\" is incorrect, expected type: ").concat(typeName),
        name: 'type',
        path: path.toArray(),
        type: typeName,
        value: value,
    };
};
var minSizeError = function (_a) {
    var min = _a.min, value = _a.value, path = _a.path;
    return {
        name: 'size',
        min: min,
        path: path.toArray(),
        details: "Size must be at least ".concat(min),
        value: value,
    };
};
var maxSizeError = function (_a) {
    var max = _a.max, value = _a.value, path = _a.path;
    return {
        name: 'size',
        max: max,
        path: path.toArray(),
        details: "Size must be at most ".concat(max),
        value: value,
    };
};
var enumError = function (_a) {
    var expected = _a.expected, value = _a.value, path = _a.path;
    return {
        details: "Value must be one of expected values",
        name: 'in',
        expected: __spreadArray([], expected, true).sort(),
        path: path.toArray(),
        value: value,
    };
};
var unknownPropertyError = function (_a) {
    var property = _a.property, path = _a.path;
    return {
        details: "The property \"".concat(property, "\" is not expected"),
        name: 'unexpected',
        path: path.toArray(),
    };
};
var requiredPropertyError = function (_a) {
    var property = _a.property, path = _a.path;
    return {
        details: "The property \"".concat(property, "\" is required here"),
        name: 'required',
        path: path.toArray(),
    };
};

var ObjectAssertion = /** @class */ (function () {
    function ObjectAssertion(obj, path) {
        var _this = this;
        this.obj = obj;
        this.path = path;
        this._errors = [];
        this.catch = function () {
            var _a;
            var errors = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                errors[_i] = arguments[_i];
            }
            (_a = _this._errors).push.apply(_a, errors);
        };
        /**
         * Asserts the key exists in the object. You probably shouldn't call this
         * function directly. Instead, use `$.object`, `$.number`, `$.string`, etc.
         */
        this.exists = function (key) {
            if (key in _this.obj) {
                return true;
            }
            _this.catch(requiredPropertyError({
                property: key,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is a plain object. if
         * no key is provided, it asserts the object itself.
         */
        this.object = function (key) {
            var _a;
            var value = key ? _this.obj[key] : _this.obj;
            if (key) {
                if (!_this.exists(key)) {
                    return false;
                }
            }
            if (isPlainObject(value)) {
                return true;
            }
            var path = key ? _this.path.of(key) : _this.path;
            var property = (_a = key !== null && key !== void 0 ? key : _this.path.last()) !== null && _a !== void 0 ? _a : 'value';
            _this.catch(typeMismatchError({
                typeName: 'Object',
                property: property,
                path: path,
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is a string.
         */
        this.string = function (key) {
            var value = _this.obj[key];
            if (key && !_this.exists(key)) {
                return false;
            }
            if (typeof value === 'string') {
                return true;
            }
            _this.catch(typeMismatchError({
                typeName: 'String',
                property: key,
                path: _this.path.of(key),
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is a number.
         */
        this.number = function (key, optional) {
            var value = _this.obj[key];
            if (optional && !(key in _this.obj)) {
                return true;
            }
            if (!_this.exists(key)) {
                return false;
            }
            if (typeof value === 'number' && !Number.isNaN(value)) {
                return true;
            }
            _this.catch(typeMismatchError({
                typeName: 'Number',
                property: key,
                path: _this.path.of(key),
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is an array. You don't
         * need to manually call this function before `$.each` or `$.maxLength`.
         */
        this.array = function (key) {
            var value = _this.obj[key];
            if (key && !_this.exists(key)) {
                return false;
            }
            if (Array.isArray(value)) {
                return true;
            }
            _this.catch(typeMismatchError({
                typeName: 'Array',
                property: key,
                path: _this.path.of(key),
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the value of the key is one of the expected values.
         */
        this.enum = function (key, expected) {
            var value = _this.obj[key];
            if (typeof value === 'string' && expected.includes(value)) {
                return true;
            }
            _this.catch(enumError({
                expected: expected,
                value: value,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the array value of the object key is empty. If the value isn't an
         * array, the function captures a type error and returns false.
         */
        this.empty = function (key) {
            if (!_this.array(key)) {
                return false;
            }
            var value = _this.obj[key];
            if (value.length === 0) {
                return true;
            }
            _this.catch(maxSizeError({
                max: 0,
                value: value,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the length of the value of the object key is at least `min`. If the
         * value isn't an array, the function captures a type error and returns false.
         */
        this.minLength = function (key, min) {
            if (!_this.array(key)) {
                return false;
            }
            var value = _this.obj[key];
            if (value.length >= min) {
                return true;
            }
            _this.catch(minSizeError({
                min: min,
                value: value,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the object has no additional properties other than the ones
         * specified
         */
        this.noAdditionalProperties = function (properties) {
            var unknowns = Object.keys(_this.obj)
                .sort()
                .filter(function (key) { return !properties.includes(key); });
            unknowns.forEach(function (property) {
                return _this.catch(unknownPropertyError({
                    property: property,
                    path: _this.path.of(property),
                }));
            });
            return unknowns.length === 0;
        };
        /**
         * Iterates over the value of the key and assert each item. If the value isn't
         * an array, the function captures a type error and safely exits.
         *
         * To maintain compatibility with previous implementation, we stop early if we
         * find any errors.
         */
        this.each = function (key, assert) {
            if (!_this.array(key)) {
                return;
            }
            var value = _this.obj[key];
            var foundErrors = false;
            value.forEach(function (item, index) {
                if (foundErrors) {
                    return;
                }
                var errors = assert(item, _this.path.of(key).of(index));
                if (errors.length > 0) {
                    foundErrors = true;
                }
                _this.catch.apply(_this, errors);
            });
        };
    }
    Object.defineProperty(ObjectAssertion.prototype, "errors", {
        get: function () {
            var _this = this;
            var serializeError = function (error) {
                return JSON.stringify({
                    details: error.details,
                    path: error.path,
                });
            };
            return this._errors.filter(function (error, index) {
                return _this._errors.findIndex(function (step) { return serializeError(error) === serializeError(step); }) === index;
            });
        },
        enumerable: false,
        configurable: true
    });
    return ObjectAssertion;
}());

var VOID_CONTENT = [];
var NodeAssertion = /** @class */ (function () {
    function NodeAssertion(contentRule, validateData) {
        this.contentRule = contentRule;
        this.validateData = validateData;
    }
    NodeAssertion.prototype.assert = function (node, path) {
        var _a, _b;
        var $ = new ObjectAssertion(node, path);
        if (!$.object()) {
            return $.errors;
        }
        $.noAdditionalProperties(['nodeType', 'data', 'content']);
        var _c = Array.isArray(this.contentRule)
            ? {
                nodeTypes: this.contentRule,
            }
            : this.contentRule(node, path), nodeTypes = _c.nodeTypes, _d = _c.min, min = _d === void 0 ? 0 : _d;
        if (nodeTypes.length === 0 && min > 0) {
            throw new Error("Invalid content rule. Cannot have enforce a 'min' of ".concat(min, " with no nodeTypes"));
        }
        $.minLength('content', min);
        // Is void
        if (nodeTypes.length === 0) {
            $.empty('content');
        }
        // Ensure content nodes have valid nodeTypes without validating the full
        // shape which is something that's only done later if the current node is
        // valid.
        else {
            $.each('content', function (item, path) {
                var item$ = new ObjectAssertion(item, path);
                if (!item$.object()) {
                    return item$.errors;
                }
                item$.enum('nodeType', nodeTypes);
                return item$.errors;
            });
        }
        if ($.object('data')) {
            var dataErrors = (_b = (_a = this.validateData) === null || _a === void 0 ? void 0 : _a.call(this, node.data, path.of('data'))) !== null && _b !== void 0 ? _b : [];
            $.catch.apply($, dataErrors);
        }
        return $.errors;
    };
    return NodeAssertion;
}());
var EntityLinkAssertion = /** @class */ (function (_super) {
    __extends(EntityLinkAssertion, _super);
    function EntityLinkAssertion(linkType, contentNodeTypes) {
        var _this = _super.call(this, contentNodeTypes, function (data, path) { return _this.assertLink(data, path); }) || this;
        _this.linkType = linkType;
        _this.assertLink = function (data, path) {
            var $ = new ObjectAssertion(data, path);
            if ($.object('target')) {
                var sys$ = new ObjectAssertion(data.target.sys, path.of('target').of('sys'));
                if (sys$.object()) {
                    sys$.enum('type', [_this.type]);
                    sys$.enum('linkType', [_this.linkType]);
                    if (_this.type === 'Link') {
                        sys$.string('id');
                        sys$.noAdditionalProperties(['type', 'linkType', 'id']);
                    }
                    else if (_this.type === 'ResourceLink') {
                        sys$.string('urn');
                        sys$.noAdditionalProperties(['type', 'linkType', 'urn']);
                    }
                }
                $.catch.apply($, sys$.errors);
            }
            $.noAdditionalProperties(['target']);
            return $.errors;
        };
        _this.type = _this.linkType.startsWith('Contentful:') ? 'ResourceLink' : 'Link';
        return _this;
    }
    return EntityLinkAssertion;
}(NodeAssertion));
var HyperLinkAssertion = /** @class */ (function (_super) {
    __extends(HyperLinkAssertion, _super);
    function HyperLinkAssertion() {
        var _this = _super.call(this, ['text'], function (data, path) { return _this.assertLink(data, path); }) || this;
        _this.assertLink = function (data, path) {
            var $ = new ObjectAssertion(data, path);
            $.string('uri');
            $.noAdditionalProperties(['uri']);
            return $.errors;
        };
        return _this;
    }
    return HyperLinkAssertion;
}(NodeAssertion));
var assert = function (contentRule, validateData) {
    return new NodeAssertion(contentRule, validateData);
};
var assertLink = function (linkType, contentRule) {
    return new EntityLinkAssertion(linkType, contentRule);
};

var Path = /** @class */ (function () {
    function Path(path) {
        if (path === void 0) { path = []; }
        var _this = this;
        this.path = path;
        this.of = function (element) {
            return new Path(__spreadArray(__spreadArray([], _this.path, true), [element], false));
        };
        this.isRoot = function () {
            return _this.path.length === 0;
        };
        this.last = function () {
            return _this.path[_this.path.length - 1];
        };
        this.toArray = function () {
            return _this.path;
        };
    }
    return Path;
}());

function assertText(text, path) {
    var $ = new ObjectAssertion(text, path);
    if (!$.object()) {
        return $.errors;
    }
    $.noAdditionalProperties(['nodeType', 'data', 'value', 'marks']);
    $.object('data');
    $.each('marks', function (mark, path) {
        var mark$ = new ObjectAssertion(mark, path);
        if (!mark$.object()) {
            return mark$.errors;
        }
        // For historical reasons, we don't explicitly check for supported marks
        // e.g. bold, italic ..etc. This makes it possible for a customer to add
        // custom marks
        mark$.string('type');
        return mark$.errors;
    });
    $.string('value');
    return $.errors;
}

var _a;
var assertInlineOrText = assert(__spreadArray(__spreadArray([], Object.values(exports.INLINES), true), ['text'], false).sort());
var assertList = assert([exports.BLOCKS.LIST_ITEM]);
var assertVoidEntryLink = assertLink('Entry', VOID_CONTENT);
var assertTableCell = assert(function () { return ({
    nodeTypes: [exports.BLOCKS.PARAGRAPH],
    min: 1,
}); }, function (data, path) {
    var $ = new ObjectAssertion(data, path);
    $.noAdditionalProperties(['colspan', 'rowspan']);
    $.number('colspan', true);
    $.number('rowspan', true);
    return $.errors;
});
var nodeValidator = (_a = {},
    _a[exports.BLOCKS.DOCUMENT] = assert(TOP_LEVEL_BLOCKS),
    _a[exports.BLOCKS.PARAGRAPH] = assertInlineOrText,
    _a[exports.BLOCKS.HEADING_1] = assertInlineOrText,
    _a[exports.BLOCKS.HEADING_2] = assertInlineOrText,
    _a[exports.BLOCKS.HEADING_3] = assertInlineOrText,
    _a[exports.BLOCKS.HEADING_4] = assertInlineOrText,
    _a[exports.BLOCKS.HEADING_5] = assertInlineOrText,
    _a[exports.BLOCKS.HEADING_6] = assertInlineOrText,
    _a[exports.BLOCKS.QUOTE] = assert(CONTAINERS[exports.BLOCKS.QUOTE]),
    _a[exports.BLOCKS.EMBEDDED_ENTRY] = assertVoidEntryLink,
    _a[exports.BLOCKS.EMBEDDED_ASSET] = assertLink('Asset', VOID_CONTENT),
    _a[exports.BLOCKS.EMBEDDED_RESOURCE] = assertLink('Contentful:Entry', VOID_CONTENT),
    _a[exports.BLOCKS.HR] = assert(VOID_CONTENT),
    _a[exports.BLOCKS.OL_LIST] = assertList,
    _a[exports.BLOCKS.UL_LIST] = assertList,
    _a[exports.BLOCKS.LIST_ITEM] = assert(__spreadArray([], LIST_ITEM_BLOCKS, true).sort()),
    _a[exports.BLOCKS.TABLE] = assert(function () { return ({
        nodeTypes: [exports.BLOCKS.TABLE_ROW],
        min: 1,
    }); }),
    _a[exports.BLOCKS.TABLE_ROW] = assert(function () { return ({
        nodeTypes: [exports.BLOCKS.TABLE_CELL, exports.BLOCKS.TABLE_HEADER_CELL],
        min: 1,
    }); }),
    _a[exports.BLOCKS.TABLE_CELL] = assertTableCell,
    _a[exports.BLOCKS.TABLE_HEADER_CELL] = assertTableCell,
    _a[exports.INLINES.HYPERLINK] = new HyperLinkAssertion(),
    _a[exports.INLINES.EMBEDDED_ENTRY] = assertVoidEntryLink,
    _a[exports.INLINES.EMBEDDED_RESOURCE] = assertLink('Contentful:Entry', VOID_CONTENT),
    _a[exports.INLINES.ENTRY_HYPERLINK] = assertLink('Entry', ['text']),
    _a[exports.INLINES.ASSET_HYPERLINK] = assertLink('Asset', ['text']),
    _a[exports.INLINES.RESOURCE_HYPERLINK] = assertLink('Contentful:Entry', ['text']),
    _a);
function validateNode(node, path) {
    if (node.nodeType === 'text') {
        return assertText(node, path);
    }
    var errors = nodeValidator[node.nodeType].assert(node, path);
    if (errors.length > 0) {
        return errors;
    }
    var $ = new ObjectAssertion(node, path);
    $.each('content', function (item, path) {
        // We already know those are valid nodes thanks to the assertion done in
        // the NodeAssertion class
        return validateNode(item, path);
    });
    return $.errors;
}
var validateRichTextDocument = function (document) {
    var path = new Path();
    var $ = new ObjectAssertion(document, path);
    if ($.object()) {
        $.enum('nodeType', [exports.BLOCKS.DOCUMENT]);
    }
    if ($.errors.length > 0) {
        return $.errors;
    }
    return validateNode(document, path);
};

exports.CONTAINERS = CONTAINERS;
exports.EMPTY_DOCUMENT = EMPTY_DOCUMENT;
exports.HEADINGS = HEADINGS;
exports.LIST_ITEM_BLOCKS = LIST_ITEM_BLOCKS;
exports.TABLE_BLOCKS = TABLE_BLOCKS;
exports.TEXT_CONTAINERS = TEXT_CONTAINERS;
exports.TOP_LEVEL_BLOCKS = TOP_LEVEL_BLOCKS;
exports.V1_MARKS = V1_MARKS;
exports.V1_NODE_TYPES = V1_NODE_TYPES;
exports.VOID_BLOCKS = VOID_BLOCKS;
exports.helpers = helpers;
exports.validateRichTextDocument = validateRichTextDocument;
//# sourceMappingURL=index.js.map
