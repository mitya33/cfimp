"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectAssertion = void 0;
var is_plain_obj_1 = __importDefault(require("is-plain-obj"));
var errors_1 = require("./errors");
var ObjectAssertion = /** @class */ (function () {
    function ObjectAssertion(obj, path) {
        var _this = this;
        this.obj = obj;
        this.path = path;
        this._errors = [];
        this.catch = function () {
            var _a;
            var errors = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                errors[_i] = arguments[_i];
            }
            (_a = _this._errors).push.apply(_a, errors);
        };
        /**
         * Asserts the key exists in the object. You probably shouldn't call this
         * function directly. Instead, use `$.object`, `$.number`, `$.string`, etc.
         */
        this.exists = function (key) {
            if (key in _this.obj) {
                return true;
            }
            _this.catch((0, errors_1.requiredPropertyError)({
                property: key,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is a plain object. if
         * no key is provided, it asserts the object itself.
         */
        this.object = function (key) {
            var _a;
            var value = key ? _this.obj[key] : _this.obj;
            if (key) {
                if (!_this.exists(key)) {
                    return false;
                }
            }
            if ((0, is_plain_obj_1.default)(value)) {
                return true;
            }
            var path = key ? _this.path.of(key) : _this.path;
            var property = (_a = key !== null && key !== void 0 ? key : _this.path.last()) !== null && _a !== void 0 ? _a : 'value';
            _this.catch((0, errors_1.typeMismatchError)({
                typeName: 'Object',
                property: property,
                path: path,
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is a string.
         */
        this.string = function (key) {
            var value = _this.obj[key];
            if (key && !_this.exists(key)) {
                return false;
            }
            if (typeof value === 'string') {
                return true;
            }
            _this.catch((0, errors_1.typeMismatchError)({
                typeName: 'String',
                property: key,
                path: _this.path.of(key),
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is a number.
         */
        this.number = function (key, optional) {
            var value = _this.obj[key];
            if (optional && !(key in _this.obj)) {
                return true;
            }
            if (!_this.exists(key)) {
                return false;
            }
            if (typeof value === 'number' && !Number.isNaN(value)) {
                return true;
            }
            _this.catch((0, errors_1.typeMismatchError)({
                typeName: 'Number',
                property: key,
                path: _this.path.of(key),
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the key exists in the object and its value is an array. You don't
         * need to manually call this function before `$.each` or `$.maxLength`.
         */
        this.array = function (key) {
            var value = _this.obj[key];
            if (key && !_this.exists(key)) {
                return false;
            }
            if (Array.isArray(value)) {
                return true;
            }
            _this.catch((0, errors_1.typeMismatchError)({
                typeName: 'Array',
                property: key,
                path: _this.path.of(key),
                value: value,
            }));
            return false;
        };
        /**
         * Asserts the value of the key is one of the expected values.
         */
        this.enum = function (key, expected) {
            var value = _this.obj[key];
            if (typeof value === 'string' && expected.includes(value)) {
                return true;
            }
            _this.catch((0, errors_1.enumError)({
                expected: expected,
                value: value,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the array value of the object key is empty. If the value isn't an
         * array, the function captures a type error and returns false.
         */
        this.empty = function (key) {
            if (!_this.array(key)) {
                return false;
            }
            var value = _this.obj[key];
            if (value.length === 0) {
                return true;
            }
            _this.catch((0, errors_1.maxSizeError)({
                max: 0,
                value: value,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the length of the value of the object key is at least `min`. If the
         * value isn't an array, the function captures a type error and returns false.
         */
        this.minLength = function (key, min) {
            if (!_this.array(key)) {
                return false;
            }
            var value = _this.obj[key];
            if (value.length >= min) {
                return true;
            }
            _this.catch((0, errors_1.minSizeError)({
                min: min,
                value: value,
                path: _this.path.of(key),
            }));
            return false;
        };
        /**
         * Asserts the object has no additional properties other than the ones
         * specified
         */
        this.noAdditionalProperties = function (properties) {
            var unknowns = Object.keys(_this.obj)
                .sort()
                .filter(function (key) { return !properties.includes(key); });
            unknowns.forEach(function (property) {
                return _this.catch((0, errors_1.unknownPropertyError)({
                    property: property,
                    path: _this.path.of(property),
                }));
            });
            return unknowns.length === 0;
        };
        /**
         * Iterates over the value of the key and assert each item. If the value isn't
         * an array, the function captures a type error and safely exits.
         *
         * To maintain compatibility with previous implementation, we stop early if we
         * find any errors.
         */
        this.each = function (key, assert) {
            if (!_this.array(key)) {
                return;
            }
            var value = _this.obj[key];
            var foundErrors = false;
            value.forEach(function (item, index) {
                if (foundErrors) {
                    return;
                }
                var errors = assert(item, _this.path.of(key).of(index));
                if (errors.length > 0) {
                    foundErrors = true;
                }
                _this.catch.apply(_this, errors);
            });
        };
    }
    Object.defineProperty(ObjectAssertion.prototype, "errors", {
        get: function () {
            var _this = this;
            var serializeError = function (error) {
                return JSON.stringify({
                    details: error.details,
                    path: error.path,
                });
            };
            return this._errors.filter(function (error, index) {
                return _this._errors.findIndex(function (step) { return serializeError(error) === serializeError(step); }) === index;
            });
        },
        enumerable: false,
        configurable: true
    });
    return ObjectAssertion;
}());
exports.ObjectAssertion = ObjectAssertion;
//# sourceMappingURL=assert.js.map