{"version":3,"file":"assert.js","sourceRoot":"","sources":["../../src/validator/assert.ts"],"names":[],"mappings":"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","sourcesContent":["import isPlainObject from 'is-plain-obj';\n\nimport { ValidationError } from '.';\nimport {\n  maxSizeError,\n  typeMismatchError,\n  enumError,\n  unknownPropertyError,\n  requiredPropertyError,\n  minSizeError,\n} from './errors';\nimport type { Path } from './path';\n\nexport class ObjectAssertion {\n  private _errors: ValidationError[] = [];\n\n  constructor(\n    private readonly obj: Record<string, any>,\n    private readonly path: Path,\n  ) {}\n\n  catch = (...errors: ValidationError[]): void => {\n    this._errors.push(...errors);\n  };\n\n  get errors(): ValidationError[] {\n    const serializeError = (error: ValidationError): string =>\n      JSON.stringify({\n        details: error.details,\n        path: error.path,\n      });\n\n    return this._errors.filter(\n      (error, index) =>\n        this._errors.findIndex((step) => serializeError(error) === serializeError(step)) === index,\n    );\n  }\n\n  /**\n   * Asserts the key exists in the object. You probably shouldn't call this\n   * function directly. Instead, use `$.object`, `$.number`, `$.string`, etc.\n   */\n  exists = (key: string): boolean => {\n    if (key in this.obj) {\n      return true;\n    }\n\n    this.catch(\n      requiredPropertyError({\n        property: key,\n        path: this.path.of(key),\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the key exists in the object and its value is a plain object. if\n   * no key is provided, it asserts the object itself.\n   */\n  public object = (key?: string): boolean => {\n    const value = key ? this.obj[key] : this.obj;\n\n    if (key) {\n      if (!this.exists(key)) {\n        return false;\n      }\n    }\n\n    if (isPlainObject(value)) {\n      return true;\n    }\n\n    const path = key ? this.path.of(key) : this.path;\n    const property = key ?? this.path.last() ?? 'value';\n\n    this.catch(\n      typeMismatchError({\n        typeName: 'Object',\n        property,\n        path,\n        value,\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the key exists in the object and its value is a string.\n   */\n  public string = (key: string): boolean => {\n    const value = this.obj[key];\n\n    if (key && !this.exists(key)) {\n      return false;\n    }\n\n    if (typeof value === 'string') {\n      return true;\n    }\n\n    this.catch(\n      typeMismatchError({\n        typeName: 'String',\n        property: key,\n        path: this.path.of(key),\n        value,\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the key exists in the object and its value is a number.\n   */\n  public number = (key: string, optional?: boolean): boolean => {\n    const value = this.obj[key];\n\n    if (optional && !(key in this.obj)) {\n      return true;\n    }\n\n    if (!this.exists(key)) {\n      return false;\n    }\n\n    if (typeof value === 'number' && !Number.isNaN(value)) {\n      return true;\n    }\n\n    this.catch(\n      typeMismatchError({\n        typeName: 'Number',\n        property: key,\n        path: this.path.of(key),\n        value,\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the key exists in the object and its value is an array. You don't\n   * need to manually call this function before `$.each` or `$.maxLength`.\n   */\n  public array = (key: string): boolean => {\n    const value = this.obj[key];\n\n    if (key && !this.exists(key)) {\n      return false;\n    }\n\n    if (Array.isArray(value)) {\n      return true;\n    }\n\n    this.catch(\n      typeMismatchError({\n        typeName: 'Array',\n        property: key,\n        path: this.path.of(key),\n        value,\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the value of the key is one of the expected values.\n   */\n  public enum = (key: string, expected: string[]): boolean => {\n    const value = this.obj[key];\n\n    if (typeof value === 'string' && expected.includes(value)) {\n      return true;\n    }\n\n    this.catch(\n      enumError({\n        expected,\n        value,\n        path: this.path.of(key),\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the array value of the object key is empty. If the value isn't an\n   * array, the function captures a type error and returns false.\n   */\n  public empty = (key: string): boolean => {\n    if (!this.array(key)) {\n      return false;\n    }\n\n    const value = this.obj[key] as Array<unknown>;\n\n    if (value.length === 0) {\n      return true;\n    }\n\n    this.catch(\n      maxSizeError({\n        max: 0,\n        value,\n        path: this.path.of(key),\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the length of the value of the object key is at least `min`. If the\n   * value isn't an array, the function captures a type error and returns false.\n   */\n  public minLength = (key: string, min: number): boolean => {\n    if (!this.array(key)) {\n      return false;\n    }\n\n    const value = this.obj[key] as Array<unknown>;\n\n    if (value.length >= min) {\n      return true;\n    }\n\n    this.catch(\n      minSizeError({\n        min,\n        value,\n        path: this.path.of(key),\n      }),\n    );\n\n    return false;\n  };\n\n  /**\n   * Asserts the object has no additional properties other than the ones\n   * specified\n   */\n  public noAdditionalProperties = (properties: string[]): boolean => {\n    const unknowns = Object.keys(this.obj)\n      .sort()\n      .filter((key) => !properties.includes(key));\n\n    unknowns.forEach((property) =>\n      this.catch(\n        unknownPropertyError({\n          property,\n          path: this.path.of(property),\n        }),\n      ),\n    );\n\n    return unknowns.length === 0;\n  };\n\n  /**\n   * Iterates over the value of the key and assert each item. If the value isn't\n   * an array, the function captures a type error and safely exits.\n   *\n   * To maintain compatibility with previous implementation, we stop early if we\n   * find any errors.\n   */\n  public each = (key: string, assert: (item: any, path: Path) => ValidationError[]): void => {\n    if (!this.array(key)) {\n      return;\n    }\n\n    const value = this.obj[key] as Array<any>;\n\n    let foundErrors = false;\n    value.forEach((item, index) => {\n      if (foundErrors) {\n        return;\n      }\n\n      const errors = assert(item, this.path.of(key).of(index));\n\n      if (errors.length > 0) {\n        foundErrors = true;\n      }\n\n      this.catch(...errors);\n    });\n  };\n}\n"]}